---
title: "Программирование в R. Домашняя работа 5"
author: "Ваше имя и фамилия"
date: 'Дата сдачи'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
```

В этой домашней работе мы наконец-то будем работать с данными, которые можно осторожно назвать большими (хотя конечно нет), а также увидим, как можно выразить политическую/идеологическую позицию на графике.

Мы будем работать с данными о голосовании всех стран мира на ежегодной Генеральной ассамблеи ООН с момента её основания (1946 г.) до 2020 г. Единица наблюдения - голосование страны за определённую резолюцию в определённый год. В каждую сессию принимается достаточно много резолюций (в среднем - около 84) и за каждую из которых каждая страна может проголосовать определённым образом. Проанализировав эти голосования и сравнив их между странами можно понять, какие союзы существуют на международной арене за тот или иной год, насколько исторически близки страны на международной арене между собой (если сравнить их за всё время), а также то, как изменения в международной повестке отражаются на голосовательном поведении разных государств.

В этой дз мы будем отвечать только на часть из этих вопросов, с остальными вы будете разбираться в следующих дз.

Кодбук данных находится по [ссылке](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/LEJUQZ)

Загрузим данные:

```{r}
load("unga_votes.rdata")
```


```{r}
library(dplyr)
library(ggplot2)
library(lubridate)
```




# 1.

В первую очередь стоит предобработать данные.

## 1.1

(1 балл)

Голосование страны по поводу резолюции записано в переменной "vote", однако не совсем понятно, что значат эти коды.

Задание:

* Создайте numeric переменную "year"
* Превратите "vote" в фактор и дайте ему корректные названия уровней (соотношение: c(1, 2, 3, 8, 9); c("Yes", "Abstain", "No", "Absent", "Not a member"));
* Выведите частотное распределение голосов за всё время;
* Выведите процентное распределение голосов за всё время;

```{r}
un <- unga_votes |>
  mutate(year = year(date), 
    vote = factor(case_when(
      vote == 1 ~ "Yes",
      vote == 2 ~ "Abstain",
      vote == 3 ~ "No",
      vote == 8 ~ "Absent",
      vote == 9 ~ "Not a member"
    )))

vote_stat <- un |>
  group_by(vote) |>
  summarise(vote_count = n(),
    vote_percent = 100 * n() / nrow(unga_votes))
```

## 1.2


(1 балл)

Задание:

* Создайте новую числовую переменную vote_new, которая будет принимать значение 1 в случае «Yes», 0 в случае «No» и 0.5 в случае «Аbstain». B иных случаях это будет миссинг;
* Узнаем, в какую сессию преобладают положительные голосования, а в какую - отрицательные. Для этого сделайте датафрейм "unga_votes_mean", где будут две колонки: (1) "date" или "year"; (2) "vote_mean" (среднее от vote_new);
* Найдите год с минимальным и максимальным значением среднего. Прокомментируйте результаты

```{r}
un <- un |>
  mutate(vote_new = case_when(
    vote == "Yes" ~ 1,
    vote == "No" ~ 0,
    vote == "Аbstain" ~ 0.5
    ))

unga_votes_mean <- un |>
  group_by(year) |>
  summarise(vote_mean = mean(vote_new, na.rm = T)) |> 
  arrange(-vote_mean)
```



# 2.

## 2.1

(1 балл) 

Нарисуйте график по распределению unga_votes_mean по годам. Обоснуйте выбор типа своего графика. 

```{r}
plot_maker <- function(data) {
ggplot(data) +
  geom_line(aes(
    x = year,
    y = vote_mean
  ))
}
plot_maker(unga_votes_mean)
```


## 2.2


(1 балл)

С помощью цикла "for" нарисуйте три графика, аналогичных тому, что вы сделали в прошлом задании, но теперь уже не для всех стран, а только для России/СССР, США и Китая. Сделайте так, чтобы в названиях графиков указывалось сокращение страны из "country". 

*Подсказка, вам понадобится функция print()*

```{r}
for (cntry in c("RUS", "USA", "CHN")) {
  print(plot_maker(
    un |>
      filter(country == cntry) |>
      group_by(year) |>
      summarise(vote_mean = mean(vote_new, na.rm = T))
    )
  )
}
```




# 3.

## 3.1

(2 балла)

Сделайте функцию, которая по запросу страны и года будет говорить, являлась ли эта страна членом ООН в тот год или нет. Ваша функция должна иметь вид:

*is_un_member('country_code', 'year')*

*Подсказка: Узнать, является ли страна членом ООН можно в переменной "vote".*

```{r}
is_un_member <- function(ctry, yr) {
  temp_df <- un |>
    filter(country == ctry & year == yr & vote == "Not a member")
  
  # Я очень хотел использовать dplyr::if_else, но почему-то код отказывался работать. Поэтому пришлось создавать временный датафрейм и проверять его размер
  if (nrow(temp_df) != 0) {
    cat(ctry, "was not a member of UN in", yr, "\n")
  } else {
    cat(ctry, "was a member of UN in", yr, "\n")
  }
}

is_un_member("AFG", 2000)
```



## 3.2

(1 балл)

Используя функцию is_un_member(), любым способом покажите, как меняется членство Китая (CHN) и Тайваня (TWN) для следующих годов: 1946, 1971, 1972, 2002, 2019.

Как вы можете это объяснить?

```{r}
for (yr in c(1946, 1971, 1972, 2002, 2019)) {
  for (cntry in c("CHN", "TWN")) {
    is_un_member(cntry, yr)
  }
}
```

>


# 4.

Попробуем в первом приближении понять как можно анализировать отношение стран друг к другу. Для этого мы предлагаем написать вам функцию, которая должна на вход принимать две страны и год, а на выход показывать коэффициент разности их голосвательного поведения. 

Как мы его получим?

Можно придумать много разных способов. Один из самых простых - отнять значения голосования за резолюцию vote_new одной страны от значений vote_new другой. Т.е. если одна страна проголосовала "1" ("Да"), а вторая "0" ("Нет"), то 1-0 = 1, что скажет нам о разнице в голосовании. Соответственно, если обе проголосовали "1" ("Да"), то мы получим 1-1 = 0. 

Суммировав (или взяв по среднему) такие разницы мы узнаем, насколько по-разному голосовали страны. Сделаем функцию, которая будет выдавать такой коэффициент для любых двух стран за определённый год.



## 4.1 

(1 балл) 

Посмотрите на функцию и вставьте в неё недостающие элементы (они помечены как "---"):

```{r eval=F}
vote_diff_coef <- function(country_1, # character
                           country_2, # character
                           year) { # numeric
  
  df_temp_1 <- unga_votes"---" # Сделайте корректную фильтрацию для первого датафрейма. Оставьте только колонки resid и vote_new
  df_temp_2 <- unga_votes"---" # Сделайте корректную фильтрацию для второго датафрейма. Оставьте только колонки resid и vote_new
  
  "---" # Создайте общий датафрейм по ключу
  "---" # Отнимите значения колонок. В случае NA оставьте NA
  
  abs("---") # Не забудьте перевести все значения в асолютные, ведь нам нужно, чтобы значения были положительные, т.к. отрицательные при сложении/взятия по средней с положительными приведут наш ответ к нулю, хотя на самом деле они показывают разницу.
  
  "---" # Выведите значение коэффициента для всех резолюций за год 

  return("---") # Настройте выдачу
  }
```



## 4.2

(1 балл)

Примените функцию. Сравните голосовательное поведение США и России в 1950, 1991, 2015 гг.


```{r}

```



# 5

(3 балла)

В R реализованы разные функции по логированию процессов. В учебных целях потренируемся писать маленькую функцию по сбору ошибок. Вместо ошибок вы можете выводить на запись итерации циклов, какие-либо внутренние параметры работы функции или содержание данных, папок и многое другое. 

Ваша задача - написать функцию error_log. Ей вы сможете оборачивать любые другие функции и в случае, если они будут давать ошибку, то error_log будет открывать специальный файл "errors_list.txt" (если его нет, то создавать его) в той же папке, в которой вы сейчас работаете и записывать туда следующую строку:

Дата Время ; Название_функции ; Ошибка 

*Например:*

"2022-11-22 22:22:22 MSK ; mean ; 'trim' must be numeric of length one"

После добавления строки, файл "закрывается" до новой ошибки (при которой всё повторяется).


Оценивание:

* Написание рабочей функции, которая ловит ошибки - 1 балл;
* Написание рабочей функции, которая корректно вписывает ошибки в .txt файл
* Апробация функции на функциях из предыдущих заданий.

```{r}

```

